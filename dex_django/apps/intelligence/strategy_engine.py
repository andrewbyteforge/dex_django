from __future__ import annotations

import asyncio
import logging
from typing import Dict, Any, List, Optional
from decimal import Decimal
from datetime import datetime, timedelta
from dataclasses import dataclass
from enum import Enum

from .market_analyzer import market_intelligence
from .risk_manager import risk_manager, TradingMode
from .cross_chain_analyzer import cross_chain_analyzer

logger = logging.getLogger("intelligence.strategy")

class StrategyType(Enum):
    SNIPER = "sniper"  # New pair sniping
    MOMENTUM = "momentum"  # Momentum trading
    ARBITRAGE = "arbitrage"  # Cross-DEX arbitrage
    MEAN_REVERSION = "mean_reversion"  # Contrarian plays

@dataclass
class TradingSignal:
    """Signal generated by strategy engine."""
    pair_address: str
    chain: str
    strategy_type: StrategyType
    action: str  # BUY, SELL, HOLD
    confidence: float  # 0-1
    urgency: str  # LOW, MEDIUM, HIGH, CRITICAL
    position_sizing: Any  # PositionSizing object
    market_analysis: Any  # MarketAnalysis object
    reasoning: List[str]
    execution_deadline: datetime
    risk_warnings: List[str]

class StrategyEngine:
    """Advanced trading strategy engine that combines all intelligence."""
    
    def __init__(self):
        self.active_strategies = [
            StrategyType.SNIPER,
            StrategyType.MOMENTUM,
            StrategyType.ARBITRAGE
        ]
        self.signal_history = []
        self.strategy_performance = {}
    
    async def generate_trading_signals(
        self,
        opportunities: List[Dict[str, Any]],
        user_balance_usd: Decimal,
        risk_mode: TradingMode = TradingMode.MODERATE
    ) -> List[TradingSignal]:
        """Generate prioritized trading signals from opportunities."""
        
        logger.info(f"Generating signals for {len(opportunities)} opportunities")
        
        # Check circuit breaker first
        if await risk_manager.check_circuit_breaker(risk_mode):
            logger.warning("Circuit breaker active - no signals generated")
            return []
        
        signals = []
        
        try:
            # Analyze each opportunity
            for opportunity in opportunities[:10]:  # Limit to top 10 for performance
                try:
                    signal = await self._analyze_opportunity(
                        opportunity, user_balance_usd, risk_mode
                    )
                    
                    if signal and signal.action in ["BUY", "STRONG_BUY"]:
                        signals.append(signal)
                        
                except Exception as e:
                    logger.error(f"Failed to analyze opportunity {opportunity.get('pair_address', 'unknown')}: {e}")
                    continue
            
            # Add cross-chain arbitrage opportunities
            if StrategyType.ARBITRAGE in self.active_strategies:
                arb_signals = await self._generate_arbitrage_signals(user_balance_usd, risk_mode)
                signals.extend(arb_signals)
            
            # Sort signals by priority score
            signals.sort(key=lambda s: self._calculate_priority_score(s), reverse=True)
            
            logger.info(f"Generated {len(signals)} trading signals")
            return signals[:5]  # Return top 5 signals
            
        except Exception as e:
            logger.error(f"Signal generation failed: {e}")
            return []
    
    async def _analyze_opportunity(
        self,
        opportunity: Dict[str, Any],
        user_balance_usd: Decimal,
        risk_mode: TradingMode
    ) -> Optional[TradingSignal]:
        """Analyze individual opportunity and generate signal."""
        
        pair_address = opportunity.get("pair_address", "")
        chain = opportunity.get("chain", "ethereum")
        
        try:
            # Get comprehensive market analysis
            market_analysis = await market_intelligence.analyze_opportunity(
                opportunity, Decimal("0.1")  # Analysis for 0.1 ETH trade
            )
            
            # Calculate position sizing
            position_sizing = await risk_manager.calculate_position_size(
                opportunity, market_analysis, user_balance_usd, risk_mode
            )
            
            # Skip if position size is too small (not worth trading)
            if position_sizing.recommended_amount_usd < Decimal("10"):
                return None
            
            # Determine strategy type
            strategy_type = self._determine_strategy_type(opportunity, market_analysis)
            
            # Generate reasoning
            reasoning = self._generate_reasoning(opportunity, market_analysis, position_sizing)
            
            # Calculate urgency
            urgency = self._calculate_urgency(opportunity, market_analysis)
            
            # Set execution deadline
            deadline = datetime.now() + timedelta(minutes=self._get_execution_window(urgency))
            
            return TradingSignal(
                pair_address=pair_address,
                chain=chain,
                strategy_type=strategy_type,
                action=market_analysis.recommendation,
                confidence=position_sizing.confidence_score,
                urgency=urgency,
                position_sizing=position_sizing,
                market_analysis=market_analysis,
                reasoning=reasoning,
                execution_deadline=deadline,
                risk_warnings=position_sizing.risk_warnings
            )
            
        except Exception as e:
            logger.error(f"Opportunity analysis failed for {pair_address}: {e}")
            return None
    
    async def _generate_arbitrage_signals(
        self,
        user_balance_usd: Decimal,
        risk_mode: TradingMode
    ) -> List[TradingSignal]:
        """Generate cross-chain arbitrage signals."""
        
        try:
            opportunities = await cross_chain_analyzer.find_cross_chain_opportunities()
            signals = []
            
            for arb_opp in opportunities[:3]:  # Top 3 arbitrage opportunities
                if arb_opp["estimated_profit_usd"] > 50:  # Minimum profit threshold
                    
                    # Create mock opportunity for risk analysis
                    mock_opportunity = {
                        "pair_address": f"arb_{arb_opp['token']}",
                        "chain": arb_opp["buy_chain"],
                        "estimated_liquidity_usd": 100000,  # Assume good liquidity
                        "token0_symbol": arb_opp["token"],
                        "token1_symbol": "USD"
                    }
                    
                    # Simple risk assessment for arbitrage
                    position_amount = min(
                        Decimal(str(arb_opp["estimated_profit_usd"]) * 10),  # 10x profit as position
                        user_balance_usd * Decimal("0.1")  # Max 10% of balance
                    )
                    
                    signals.append(TradingSignal(
                        pair_address=mock_opportunity["pair_address"],
                        chain=arb_opp["buy_chain"],
                        strategy_type=StrategyType.ARBITRAGE,
                        action="BUY",
                        confidence=0.8,
                        urgency="HIGH",
                        position_sizing=None,  # Arbitrage has different sizing logic
                        market_analysis=None,
                        reasoning=[
                            f"Cross-chain arbitrage: {arb_opp['buy_chain']} -> {arb_opp['sell_chain']}",
                            f"Estimated profit: ${arb_opp['estimated_profit_usd']}",
                            f"Spread: {arb_opp['spread_percentage']:.2f}%"
                        ],
                        execution_deadline=datetime.now() + timedelta(minutes=5),  # Act quickly
                        risk_warnings=[f"Bridge time: {arb_opp['execution_time_minutes']} minutes"]
                    ))
            
            return signals
            
        except Exception as e:
            logger.error(f"Arbitrage signal generation failed: {e}")
            return []
    
    def _determine_strategy_type(self, opportunity: Dict[str, Any], analysis: Any) -> StrategyType:
        """Determine the best strategy type for the opportunity."""
        
        # Check if this is a new pair (sniping opportunity)
        try:
            timestamp = opportunity.get("timestamp", "")
            if timestamp:
                pair_age = datetime.now() - datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
                if pair_age < timedelta(hours=1):
                    return StrategyType.SNIPER
        except:
            pass
        
        # Check for momentum signals
        if hasattr(analysis, 'momentum_score') and analysis.momentum_score > 7:
            return StrategyType.MOMENTUM
        
        # Default to sniper for new opportunities
        return StrategyType.SNIPER
    
    def _generate_reasoning(
        self,
        opportunity: Dict[str, Any],
        analysis: Any,
        position_sizing: Any
    ) -> List[str]:
        """Generate human-readable reasoning for the trading decision."""
        
        reasoning = []
        
        # Risk assessment
        if hasattr(analysis, 'overall_risk_score'):
            risk_score = analysis.overall_risk_score
            if risk_score < 30:
                reasoning.append(f"âœ“ Low risk score: {risk_score:.1f}/100")
            elif risk_score < 50:
                reasoning.append(f"â— Medium risk score: {risk_score:.1f}/100")
            else:
                reasoning.append(f"âš  High risk score: {risk_score:.1f}/100")
        
        # Liquidity assessment
        liquidity = opportunity.get("estimated_liquidity_usd", 0)
        if liquidity > 100000:
            reasoning.append(f"âœ“ Strong liquidity: ${liquidity:,.0f}")
        elif liquidity > 50000:
            reasoning.append(f"â— Adequate liquidity: ${liquidity:,.0f}")
        else:
            reasoning.append(f"âš  Low liquidity: ${liquidity:,.0f}")
        
        # Momentum assessment
        if hasattr(analysis, 'momentum_score'):
            momentum = analysis.momentum_score
            if momentum > 7:
                reasoning.append(f"âœ“ Strong momentum: {momentum:.1f}/10")
            elif momentum > 5:
                reasoning.append(f"â— Positive momentum: {momentum:.1f}/10")
            else:
                reasoning.append(f"âš  Weak momentum: {momentum:.1f}/10")
        
        # Position sizing rationale
        recommended = position_sizing.recommended_amount_usd
        reasoning.append(f"ðŸ’° Position size: ${recommended}")
        
        return reasoning
    
    def _calculate_urgency(self, opportunity: Dict[str, Any], analysis: Any) -> str:
        """Calculate execution urgency based on opportunity characteristics."""
        
        urgency_score = 0
        
        # New pairs are more urgent
        try:
            timestamp = opportunity.get("timestamp", "")
            if timestamp:
                pair_age = datetime.now() - datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
                if pair_age < timedelta(minutes=30):
                    urgency_score += 3  # CRITICAL
                elif pair_age < timedelta(hours=2):
                    urgency_score += 2  # HIGH
                elif pair_age < timedelta(hours=12):
                    urgency_score += 1  # MEDIUM
        except:
            pass
        
        # High momentum increases urgency
        if hasattr(analysis, 'momentum_score') and analysis.momentum_score > 8:
            urgency_score += 2
        elif hasattr(analysis, 'momentum_score') and analysis.momentum_score > 6:
            urgency_score += 1
        
        # Mempool activity increases urgency
        if (hasattr(analysis, 'mempool_intelligence') and 
            analysis.mempool_intelligence and 
            len(analysis.mempool_intelligence.get('bot_competition', [])) > 3):
            urgency_score += 1
        
        # Map score to urgency levels
        if urgency_score >= 4:
            return "CRITICAL"
        elif urgency_score >= 3:
            return "HIGH"
        elif urgency_score >= 2:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _get_execution_window(self, urgency: str) -> int:
        """Get execution window in minutes based on urgency."""
        
        windows = {
            "CRITICAL": 2,   # 2 minutes
            "HIGH": 5,       # 5 minutes
            "MEDIUM": 15,    # 15 minutes
            "LOW": 60        # 1 hour
        }
        
        return windows.get(urgency, 15)
    
    def _calculate_priority_score(self, signal: TradingSignal) -> float:
        """Calculate priority score for signal ranking."""
        
        score = 0.0
        
        # Base confidence weight (40%)
        score += signal.confidence * 0.4
        
        # Urgency weight (30%)
        urgency_weights = {"CRITICAL": 1.0, "HIGH": 0.8, "MEDIUM": 0.6, "LOW": 0.4}
        score += urgency_weights.get(signal.urgency, 0.4) * 0.3
        
        # Position size weight (20%) - larger positions get higher priority
        if signal.position_sizing:
            size_score = min(float(signal.position_sizing.recommended_amount_usd) / 1000, 1.0)
            score += size_score * 0.2
        
        # Strategy type weight (10%)
        strategy_weights = {
            StrategyType.SNIPER: 1.0,      # Highest priority
            StrategyType.ARBITRAGE: 0.9,   # High priority
            StrategyType.MOMENTUM: 0.8,    # Medium priority
            StrategyType.MEAN_REVERSION: 0.6  # Lower priority
        }
        score += strategy_weights.get(signal.strategy_type, 0.5) * 0.1
        
        return score


# Global strategy engine instance
strategy_engine = StrategyEngine()